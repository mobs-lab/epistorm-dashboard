// src/app/store/forecastSettingsSlice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { EvaluationsSeasonOverviewSeasonOption, AggregationPeriod } from "@/interfaces/forecast-interfaces";
import { parseISO } from "date-fns";
import { modelNames } from "@/interfaces/epistorm-constants";

interface EvaluationsSeasonOverviewSettingsState {
  /* Location Related */
  /* evaluationSeasonOverviewSelectedStateCode: string;
  evaluationSeasonOverviewSelectedStateName: string; */

  /* Model Related*/
  evaluationSeasonOverviewHorizon: number[]; //how many weeks ahead from reference date (matching surveillance week's number) should we look for as target_end_date in predictions to draw the intervals
  evaluationSeasonOverviewSelectedModels: String[];

  /* Time Range Related */
  evaluationSeasonOverviewSeasonOptions: EvaluationsSeasonOverviewSeasonOption[];
  aggregationPeriods: AggregationPeriod[];
  selectedAggregationPeriod: string;

  // store the reference date for SO Settings Panel
  // Note: Everytime the score option refreshes, this is obtained through comparing two things:
  // latest ref date from surveillance vs latest ref date from prediction
  // See below for implementation
  latestReferenceDate: Date | null;

  /* Map selection panel related */
  mapSelectedModel: string;
  mapSelectedScoringOption: "WIS/Baseline" | "MAPE" | "Coverage";
  useLogColorScale: boolean;

  /* For Aggregated Box Plots, toggling linear/log mode display */
  wisChartScaleType: "linear" | "log";
  mapeChartScaleType: "linear" | "log";
}

interface UpdateDynamicPeriodsPayload {
  latestReferenceDate: Date;
  dynamicPeriods: {
    last2Weeks: { startDate: Date; endDate: Date };
    last4Weeks: { startDate: Date; endDate: Date };
    last8Weeks: { startDate: Date; endDate: Date };
  };
}

/* NOTE: Static Initial Value based implementation for generating aggregated time period options for Evaluations-Season-Overview page, change to dynamically-generated by lifting this logic into DataProvider, trigger when fetching. However, this should work for now and is slightly faster. */

// Define the predefined aggregation periods
const predefinedAggregationPeriods: AggregationPeriod[] = [
  {
    id: "season-2021-2022",
    label: "2021-2022",
    startDate: parseISO("2021-08-01T00:00:00Z"),
    endDate: parseISO("2022-07-31T23:59:59Z"),
  },
  {
    id: "season-2022-2023",
    label: "2022-2023",
    startDate: parseISO("2022-08-01T00:00:00Z"),
    endDate: parseISO("2023-07-31T23:59:59Z"),
  },
  {
    id: "season-2023-2024",
    label: "2023-2024",
    startDate: parseISO("2023-08-01T00:00:00Z"),
    endDate: parseISO("2024-07-31T23:59:59Z"),
  },
  {
    id: "season-2024-2025",
    label: "2024-2025 (Ongoing)",
    startDate: parseISO("2024-08-01T00:00:00Z"),
    endDate: parseISO("2025-07-31T23:59:59Z"),
  },
  /* The `new Date()` will all be replaced by calculated dates */
  {
    id: "last-2-weeks",
    label: "Last 2 weeks",
    startDate: new Date(),
    endDate: new Date(),
    isDynamic: true,
  },
  {
    id: "last-4-weeks",
    label: "Last 4 weeks",
    startDate: new Date(),
    endDate: new Date(),
    isDynamic: true,
  },
  {
    id: "last-8-weeks",
    label: "Last 8 weeks",
    startDate: new Date(),
    endDate: new Date(),
    isDynamic: true,
  },
];

const initialState: EvaluationsSeasonOverviewSettingsState = {
  /* Location Defaults */
  /* evaluationSeasonOverviewSelectedStateCode: "US",
  evaluationSeasonOverviewSelectedStateName: "United States", */

  /* Model Defaults*/
  evaluationSeasonOverviewHorizon: [0, 1],
  evaluationSeasonOverviewSelectedModels: [...modelNames],

  /* Time Range Defaults*/
  evaluationSeasonOverviewSeasonOptions: [],

  selectedAggregationPeriod: "last-2-weeks",
  aggregationPeriods: predefinedAggregationPeriods,
  latestReferenceDate: null,

  mapSelectedModel: modelNames[0], // Set default to first model
  mapSelectedScoringOption: "WIS/Baseline", // Default scoring option
  useLogColorScale: false,

  wisChartScaleType: "linear",
  mapeChartScaleType: "linear",
};

const evaluationsSeasonOverviewSettingsSlice = createSlice({
  name: "evaluations-season-overview-settings-slice",
  initialState,
  reducers: {
    setEvaluationSeasonOverviewHorizon: (state, action: PayloadAction<number[]>) => {
      state.evaluationSeasonOverviewHorizon = action.payload;
    },
    updateEvaluationSeasonOverviewSeasonOptions: (state, action: PayloadAction<EvaluationsSeasonOverviewSeasonOption[]>) => {
      state.evaluationSeasonOverviewSeasonOptions = action.payload;
    },
    updateSelectedAggregationPeriod: (state, action: PayloadAction<string>) => {
      state.selectedAggregationPeriod = action.payload;
    },
    updateDynamicPeriods: (state, action: PayloadAction<UpdateDynamicPeriodsPayload>) => {
      const { latestReferenceDate, dynamicPeriods } = action.payload;

      state.latestReferenceDate = latestReferenceDate;

      // Simply update the aggregation periods with precalculated values
      state.aggregationPeriods = state.aggregationPeriods.map((period) => {
        if (period.isDynamic) {
          if (period.id === "last-2-weeks") {
            return {
              ...period,
              startDate: dynamicPeriods.last2Weeks.startDate,
              endDate: dynamicPeriods.last2Weeks.endDate,
            };
          } else if (period.id === "last-4-weeks") {
            return {
              ...period,
              startDate: dynamicPeriods.last4Weeks.startDate,
              endDate: dynamicPeriods.last4Weeks.endDate,
            };
          } else if (period.id === "last-8-weeks") {
            return {
              ...period,
              startDate: dynamicPeriods.last8Weeks.startDate,
              endDate: dynamicPeriods.last8Weeks.endDate,
            };
          }
        }
        return period;
      });
    },
    setMapSelectedModel: (state, action: PayloadAction<string>) => {
      state.mapSelectedModel = action.payload;
    },
    setMapSelectedScoringOption: (state, action: PayloadAction<"WIS/Baseline" | "MAPE" | "Coverage">) => {
      state.mapSelectedScoringOption = action.payload;
    },
    setUseLogColorScale: (state, action: PayloadAction<boolean>) => {
      state.useLogColorScale = action.payload;
    },
    toggleModelSelection: (state, action: PayloadAction<string>) => {
      const modelName = action.payload;
      const index = state.evaluationSeasonOverviewSelectedModels.indexOf(modelName);
      if (index === -1) {
        // Model not currently selected, add it
        state.evaluationSeasonOverviewSelectedModels.push(modelName);
      } else {
        // Model currently selected, remove it
        state.evaluationSeasonOverviewSelectedModels.splice(index, 1);
      }
    },
    selectAllModels: (state) => {
      state.evaluationSeasonOverviewSelectedModels = [...modelNames];
    },
    setWisChartScaleType: (state, action: PayloadAction<"linear" | "log">) => {
      state.wisChartScaleType = action.payload;
    },
    setMapeChartScaleType: (state, action: PayloadAction<"linear" | "log">) => {
      state.mapeChartScaleType = action.payload;
    },
  },
});

export const {
  setEvaluationSeasonOverviewHorizon,
  updateEvaluationSeasonOverviewSeasonOptions,
  updateSelectedAggregationPeriod,
  updateDynamicPeriods,
  setMapSelectedModel,
  setMapSelectedScoringOption,
  setUseLogColorScale,
  toggleModelSelection,
  selectAllModels,

  setWisChartScaleType,
  setMapeChartScaleType,
} = evaluationsSeasonOverviewSettingsSlice.actions;

export default evaluationsSeasonOverviewSettingsSlice.reducer;
