// src/app/store/forecastSettingsSlice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import {
  EvaluationsSeasonOverviewSeasonOption,
  AggregationPeriod,
} from "@/interfaces/forecast-interfaces";
import { parseISO, subWeeks } from "date-fns";

interface EvaluationsSeasonOverviewSettingsState {
  /* Model Related*/
  evaluationSeasonOverviewHorizon: number; //how many weeks ahead from reference date (matching surveillance week's number) should we look for as target_end_date in predictions to draw the intervals

  /* Time Range Related */
  evaluationSeasonOverviewSeasonOptions: EvaluationsSeasonOverviewSeasonOption[];

  selectedAggregationPeriod: string;
  aggregationPeriods: AggregationPeriod[];
}

/* NOTE: Static Initial Value based implementation for generating aggregated time period options for Evaluations-Season-Overview page, change to dynamically-generated by lifting this logic into DataProvider, trigger when fetching. However, this should work for now and is slightly faster. */
const currentDate = new Date();

// Define the predefined aggregation periods
const predefinedAggregationPeriods: AggregationPeriod[] = [
  {
    id: "season-2023-2024",
    label: "2023-2024",
    startDate: parseISO("2023-08-01T00:00:00Z"),
    endDate: parseISO("2024-07-31T23:59:59Z"),
  },
  {
    id: "season-2024-2025",
    label: "2024-2025",
    startDate: parseISO("2024-08-01T00:00:00Z"),
    endDate: parseISO("2025-07-31T23:59:59Z"),
  },
  {
    id: "last-2-weeks",
    label: "Last 2 weeks",
    startDate: subWeeks(currentDate, 2),
    endDate: currentDate,
    isDynamic: true,
  },
  {
    id: "last-4-weeks",
    label: "Last 4 weeks",
    startDate: subWeeks(currentDate, 4),
    endDate: currentDate,
    isDynamic: true,
  },
  {
    id: "last-8-weeks",
    label: "Last 8 weeks",
    startDate: subWeeks(currentDate, 8),
    endDate: currentDate,
    isDynamic: true,
  },
];

const initialState: EvaluationsSeasonOverviewSettingsState = {
  /* Model Defaults*/
  evaluationSeasonOverviewHorizon: 0,

  /* Time Range Defaults*/
  evaluationSeasonOverviewSeasonOptions: [],

  selectedAggregationPeriod: "season-2023-2024",
  aggregationPeriods: predefinedAggregationPeriods,
};

const evaluationsSeasonOverviewSettingsSlice = createSlice({
  name: "evaluations-single-model-settings-slice",
  initialState,
  reducers: {
    updateEvaluationSeasonOverviewHorizon: (
      state,
      action: PayloadAction<number>
    ) => {
      state.evaluationSeasonOverviewHorizon = action.payload;
    },
    updateEvaluationSeasonOverviewSeasonOptions: (
      state,
      action: PayloadAction<EvaluationsSeasonOverviewSeasonOption[]>
    ) => {
      state.evaluationSeasonOverviewSeasonOptions = action.payload;
    },
    updateSelectedAggregationPeriod: (state, action: PayloadAction<string>) => {
      state.selectedAggregationPeriod = action.payload;
    },
    // This helper action can be used to refresh the dynamic date ranges
    refreshDynamicDateRanges: (state) => {
      const currentDate = new Date();

      state.aggregationPeriods = state.aggregationPeriods.map((period) => {
        if (period.isDynamic) {
          if (period.id === "last-2-weeks") {
            return {
              ...period,
              startDate: subWeeks(currentDate, 2),
              endDate: currentDate,
            };
          } else if (period.id === "last-4-weeks") {
            return {
              ...period,
              startDate: subWeeks(currentDate, 4),
              endDate: currentDate,
            };
          } else if (period.id === "last-8-weeks") {
            return {
              ...period,
              startDate: subWeeks(currentDate, 8),
              endDate: currentDate,
            };
          }
        }
        return period;
      });
    },
  },
});

export const {
  updateEvaluationSeasonOverviewHorizon,
  updateEvaluationSeasonOverviewSeasonOptions,
  updateSelectedAggregationPeriod,
  refreshDynamicDateRanges
} = evaluationsSeasonOverviewSettingsSlice.actions;

export default evaluationsSeasonOverviewSettingsSlice.reducer;
