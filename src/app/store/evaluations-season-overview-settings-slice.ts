// src/app/store/forecastSettingsSlice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { EvaluationsSeasonOverviewSeasonOption, AggregationPeriod } from "@/interfaces/forecast-interfaces";
import { parseISO } from "date-fns";

interface EvaluationsSeasonOverviewSettingsState {
  /* Location Related */
  evaluationSeasonOverviewSelectedStateCode: string;
  evaluationSeasonOverviewSelectedStateName: string;

  /* Model Related*/
  evaluationSeasonOverviewHorizon: number[]; //how many weeks ahead from reference date (matching surveillance week's number) should we look for as target_end_date in predictions to draw the intervals

  /* Time Range Related */
  evaluationSeasonOverviewSeasonOptions: EvaluationsSeasonOverviewSeasonOption[];
  aggregationPeriods: AggregationPeriod[];
  selectedAggregationPeriod: string;

  // store the reference date for SO Settings Panel
  // Note: Everytime the score option refreshes, this is obtained through comparing two things:
  // latest ref date from surveillance vs latest ref date from prediction
  // See below for implementation
  latestReferenceDate: Date | null;
}

interface UpdateDynamicPeriodsPayload {
  latestReferenceDate: Date;
  dynamicPeriods: {
    last2Weeks: { startDate: Date; endDate: Date };
    last4Weeks: { startDate: Date; endDate: Date };
    last8Weeks: { startDate: Date; endDate: Date };
  };
}

/* NOTE: Static Initial Value based implementation for generating aggregated time period options for Evaluations-Season-Overview page, change to dynamically-generated by lifting this logic into DataProvider, trigger when fetching. However, this should work for now and is slightly faster. */

// Define the predefined aggregation periods
const predefinedAggregationPeriods: AggregationPeriod[] = [
  {
    id: "season-2023-2024",
    label: "2023-2024",
    startDate: parseISO("2023-08-01T00:00:00Z"),
    endDate: parseISO("2024-07-31T23:59:59Z"),
  },
  {
    id: "season-2024-2025",
    label: "2024-2025 (Ongoing)",
    startDate: parseISO("2024-08-01T00:00:00Z"),
    endDate: parseISO("2025-07-31T23:59:59Z"),
  },
  /* The `new Date()` will all be replaced by calculated dates */
  {
    id: "last-2-weeks",
    label: "Last 2 weeks",
    startDate: new Date(),
    endDate: new Date(),
    isDynamic: true,
  },
  {
    id: "last-4-weeks",
    label: "Last 4 weeks",
    startDate: new Date(),
    endDate: new Date(),
    isDynamic: true,
  },
  {
    id: "last-8-weeks",
    label: "Last 8 weeks",
    startDate: new Date(),
    endDate: new Date(),
    isDynamic: true,
  },
];

const initialState: EvaluationsSeasonOverviewSettingsState = {
  /* Location Defaults */
  evaluationSeasonOverviewSelectedStateCode: "US",
  evaluationSeasonOverviewSelectedStateName: "United States",

  /* Model Defaults*/
  evaluationSeasonOverviewHorizon: [],

  /* Time Range Defaults*/
  evaluationSeasonOverviewSeasonOptions: [],

  selectedAggregationPeriod: "season-2023-2024",
  aggregationPeriods: predefinedAggregationPeriods,
  latestReferenceDate: null,
};

const evaluationsSeasonOverviewSettingsSlice = createSlice({
  name: "evaluations-season-overview-settings-slice",
  initialState,
  reducers: {
    setEvaluationSeasonOverviewHorizon: (state, action: PayloadAction<number[]>) => {
      state.evaluationSeasonOverviewHorizon = action.payload;
    },
    updateEvaluationSeasonOverviewSeasonOptions: (state, action: PayloadAction<EvaluationsSeasonOverviewSeasonOption[]>) => {
      state.evaluationSeasonOverviewSeasonOptions = action.payload;
    },
    updateSelectedAggregationPeriod: (state, action: PayloadAction<string>) => {
      state.selectedAggregationPeriod = action.payload;
    },
    updateEvaluationSeasonOverviewSelectedState: (state, action: PayloadAction<{ stateCode: string; stateName: string }>) => {
      state.evaluationSeasonOverviewSelectedStateCode = action.payload.stateCode;
      state.evaluationSeasonOverviewSelectedStateName = action.payload.stateName;
    },
    updateDynamicPeriods: (state, action: PayloadAction<UpdateDynamicPeriodsPayload>) => {
      const { latestReferenceDate, dynamicPeriods } = action.payload;

      state.latestReferenceDate = latestReferenceDate;

      // Simply update the aggregation periods with precalculated values
      state.aggregationPeriods = state.aggregationPeriods.map((period) => {
        if (period.isDynamic) {
          if (period.id === "last-2-weeks") {
            return {
              ...period,
              startDate: dynamicPeriods.last2Weeks.startDate,
              endDate: dynamicPeriods.last2Weeks.endDate,
            };
          } else if (period.id === "last-4-weeks") {
            return {
              ...period,
              startDate: dynamicPeriods.last4Weeks.startDate,
              endDate: dynamicPeriods.last4Weeks.endDate,
            };
          } else if (period.id === "last-8-weeks") {
            return {
              ...period,
              startDate: dynamicPeriods.last8Weeks.startDate,
              endDate: dynamicPeriods.last8Weeks.endDate,
            };
          }
        }
        return period;
      });
    },
  },
});

export const {
  setEvaluationSeasonOverviewHorizon,
  updateEvaluationSeasonOverviewSeasonOptions,
  updateEvaluationSeasonOverviewSelectedState,
  updateSelectedAggregationPeriod,
  updateDynamicPeriods,
} = evaluationsSeasonOverviewSettingsSlice.actions;

export default evaluationsSeasonOverviewSettingsSlice.reducer;
