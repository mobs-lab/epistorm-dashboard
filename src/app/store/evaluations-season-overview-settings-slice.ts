// src/app/store/forecastSettingsSlice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { EvaluationsSeasonOverviewSeasonOption, AggregationPeriod, ModelPrediction } from "@/interfaces/forecast-interfaces";
import { parseISO, subWeeks, format, addWeeks } from "date-fns";

interface EvaluationsSeasonOverviewSettingsState {
  /* Model Related*/
  evaluationSeasonOverviewHorizon: number[]; //how many weeks ahead from reference date (matching surveillance week's number) should we look for as target_end_date in predictions to draw the intervals

  /* Time Range Related */
  evaluationSeasonOverviewSeasonOptions: EvaluationsSeasonOverviewSeasonOption[];
  aggregationPeriods: AggregationPeriod[];
  selectedAggregationPeriod: string;

  // store the reference date for SO Settings Panel
  latestReferenceDate: Date | null;
}

interface RefreshDynamicDateRangesPayload {
  predictions: ModelPrediction[];
  maxHorizon: number;
}

/* NOTE: Static Initial Value based implementation for generating aggregated time period options for Evaluations-Season-Overview page, change to dynamically-generated by lifting this logic into DataProvider, trigger when fetching. However, this should work for now and is slightly faster. */

// Define the predefined aggregation periods
const predefinedAggregationPeriods: AggregationPeriod[] = [
  {
    id: "season-2023-2024",
    label: "2023-2024",
    startDate: parseISO("2023-08-01T00:00:00Z"),
    endDate: parseISO("2024-07-31T23:59:59Z"),
  },
  {
    id: "season-2024-2025",
    label: "2024-2025",
    startDate: parseISO("2024-08-01T00:00:00Z"),
    endDate: parseISO("2025-07-31T23:59:59Z"),
  },
  /* The `new Date()` will all be replaced by calculated dates */
  {
    id: "last-2-weeks",
    label: "Last 2 weeks",
    startDate: new Date(),
    endDate: new Date(),
    isDynamic: true,
  },
  {
    id: "last-4-weeks",
    label: "Last 4 weeks",
    startDate: new Date(),
    endDate: new Date(),
    isDynamic: true,
  },
  {
    id: "last-8-weeks",
    label: "Last 8 weeks",
    startDate: new Date(),
    endDate: new Date(),
    isDynamic: true,
  },
];

const initialState: EvaluationsSeasonOverviewSettingsState = {
  /* Model Defaults*/
  evaluationSeasonOverviewHorizon: [],

  /* Time Range Defaults*/
  evaluationSeasonOverviewSeasonOptions: [],

  selectedAggregationPeriod: "season-2023-2024",
  aggregationPeriods: predefinedAggregationPeriods,
  latestReferenceDate: null,
};

// Helper function to find the latest reference date with valid prediction data
const findLatestReferenceDate = (predictions: ModelPrediction[]): Date => {
  return predictions.reduce((latestDate, model) => {
    if (!model.predictionData.length) return latestDate;

    const modelLatestRef = model.predictionData.reduce(
      (latest, pred) => (pred.referenceDate > latest ? pred.referenceDate : latest),
      new Date(0)
    );

    return modelLatestRef > latestDate ? modelLatestRef : latestDate;
  }, new Date(0));
};

const evaluationsSeasonOverviewSettingsSlice = createSlice({
  name: "evaluations-season-overview-settings-slice",
  initialState,
  reducers: {
    setEvaluationSeasonOverviewHorizon: (state, action: PayloadAction<number[]>) => {
      state.evaluationSeasonOverviewHorizon = action.payload;
    },
    updateEvaluationSeasonOverviewSeasonOptions: (state, action: PayloadAction<EvaluationsSeasonOverviewSeasonOption[]>) => {
      state.evaluationSeasonOverviewSeasonOptions = action.payload;
    },
    updateSelectedAggregationPeriod: (state, action: PayloadAction<string>) => {
      state.selectedAggregationPeriod = action.payload;
    },

    // Refresh dynamic date ranges based on latest reference date and selected horizons
    // Triggered by Data Provider after surveillance + predictions are loaded
    refreshDynamicDateRanges: (state, action: PayloadAction<RefreshDynamicDateRangesPayload>) => {
      const { predictions, maxHorizon } = action.payload;

      // Find the latest reference date with valid prediction data
      const latestReferenceDate = findLatestReferenceDate(predictions);

      // Store the reference date for UI purposes
      state.latestReferenceDate = latestReferenceDate;

      // Add horizon weeks to get the end date for dynamic options
      // This ensures we include data for all selected horizons
      const referenceEndDate = addWeeks(latestReferenceDate, maxHorizon);

      state.aggregationPeriods = state.aggregationPeriods.map((period) => {
        if (period.isDynamic) {
          if (period.id === "last-2-weeks") {
            return {
              ...period,
              startDate: subWeeks(referenceEndDate, 2),
              endDate: referenceEndDate,
            };
          } else if (period.id === "last-4-weeks") {
            return {
              ...period,
              startDate: subWeeks(referenceEndDate, 4),
              endDate: referenceEndDate,
            };
          } else if (period.id === "last-8-weeks") {
            return {
              ...period,
              startDate: subWeeks(referenceEndDate, 8),
              endDate: referenceEndDate,
            };
          }
        }
        return period;
      });
    },
  },
});

export const {
  setEvaluationSeasonOverviewHorizon,
  updateEvaluationSeasonOverviewSeasonOptions,
  updateSelectedAggregationPeriod,
  refreshDynamicDateRanges,
} = evaluationsSeasonOverviewSettingsSlice.actions;

export default evaluationsSeasonOverviewSettingsSlice.reducer;
